<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>SniperSight - Scope View</title>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }

    body {
      background: #000;
      min-height: 100vh;
      overflow: hidden;
    }

    .container {
      position: relative;
      width: 100vw;
      height: 100vh;
      display: flex;
      align-items: center;
      justify-content: center;
    }

    #scope-canvas {
      width: 100%;
      height: 100%;
    }

    /* Scope mask - blacks out everything outside the circle */
    .scope-mask {
      position: fixed;
      inset: 0;
      pointer-events: none;
      z-index: 5;
    }

    .scope-mask svg {
      width: 100%;
      height: 100%;
    }

    /* Scope reticle overlay */
    .scope-reticle {
      position: fixed;
      inset: 0;
      pointer-events: none;
      z-index: 10;
    }

    .scope-reticle svg {
      width: 100%;
      height: 100%;
    }

    /* Subtle scan line inside scope */
    .scan-line {
      position: fixed;
      left: 25%;
      right: 25%;
      height: 1px;
      background: linear-gradient(90deg, transparent, rgba(0, 255, 136, 0.3), transparent);
      animation: scanV 5s linear infinite;
      pointer-events: none;
      z-index: 15;
    }

    @keyframes scanV {
      0% { top: 25%; opacity: 0; }
      10% { opacity: 1; }
      90% { opacity: 1; }
      100% { top: 75%; opacity: 0; }
    }

    /* Scope edge glow */
    .scope-glow {
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      width: 55vmin;
      height: 55vmin;
      border-radius: 50%;
      box-shadow: 
        inset 0 0 60px rgba(0, 255, 136, 0.1),
        inset 0 0 120px rgba(0, 0, 0, 0.5);
      pointer-events: none;
      z-index: 6;
    }
  </style>
</head>
<body>
  <div class="container">
    <canvas id="scope-canvas"></canvas>
  </div>

  <!-- Scope mask - circular cutout, everything else black -->
  <div class="scope-mask">
    <svg viewBox="0 0 100 100" preserveAspectRatio="xMidYMid slice">
      <defs>
        <mask id="scopeMask">
          <rect width="100" height="100" fill="white"/>
          <circle cx="50" cy="50" r="26" fill="black"/>
        </mask>
      </defs>
      <!-- Black overlay with circular hole -->
      <rect width="100" height="100" fill="#000" mask="url(#scopeMask)"/>
      <!-- Scope rim -->
      <circle cx="50" cy="50" r="26" fill="none" stroke="#111" stroke-width="1.5"/>
      <circle cx="50" cy="50" r="26.8" fill="none" stroke="#1a1a1a" stroke-width="0.3"/>
    </svg>
  </div>

  <!-- Inner scope glow -->
  <div class="scope-glow"></div>

  <!-- Scope reticle overlay - more prominent -->
  <div class="scope-reticle">
    <svg viewBox="0 0 100 100" preserveAspectRatio="xMidYMid slice">
      <!-- Main crosshairs - thicker, more visible -->
      <!-- Top -->
      <line x1="50" y1="24" x2="50" y2="42" stroke="#00ff88" stroke-width="0.2" opacity="0.9"/>
      <line x1="50" y1="24" x2="50" y2="42" stroke="#00ff88" stroke-width="0.8" opacity="0.2"/>
      <!-- Bottom -->
      <line x1="50" y1="58" x2="50" y2="76" stroke="#00ff88" stroke-width="0.2" opacity="0.9"/>
      <line x1="50" y1="58" x2="50" y2="76" stroke="#00ff88" stroke-width="0.8" opacity="0.2"/>
      <!-- Left -->
      <line x1="24" y1="50" x2="42" y2="50" stroke="#00ff88" stroke-width="0.2" opacity="0.9"/>
      <line x1="24" y1="50" x2="42" y2="50" stroke="#00ff88" stroke-width="0.8" opacity="0.2"/>
      <!-- Right -->
      <line x1="58" y1="50" x2="76" y2="50" stroke="#00ff88" stroke-width="0.2" opacity="0.9"/>
      <line x1="58" y1="50" x2="76" y2="50" stroke="#00ff88" stroke-width="0.8" opacity="0.2"/>

      <!-- Center targeting brackets - prominent -->
      <path d="M 46 46 L 46 43 L 43 43" fill="none" stroke="#00ff88" stroke-width="0.3" opacity="1"/>
      <path d="M 54 46 L 54 43 L 57 43" fill="none" stroke="#00ff88" stroke-width="0.3" opacity="1"/>
      <path d="M 46 54 L 46 57 L 43 57" fill="none" stroke="#00ff88" stroke-width="0.3" opacity="1"/>
      <path d="M 54 54 L 54 57 L 57 57" fill="none" stroke="#00ff88" stroke-width="0.3" opacity="1"/>
      <!-- Bracket glow -->
      <path d="M 46 46 L 46 43 L 43 43" fill="none" stroke="#00ff88" stroke-width="1" opacity="0.2"/>
      <path d="M 54 46 L 54 43 L 57 43" fill="none" stroke="#00ff88" stroke-width="1" opacity="0.2"/>
      <path d="M 46 54 L 46 57 L 43 57" fill="none" stroke="#00ff88" stroke-width="1" opacity="0.2"/>
      <path d="M 54 54 L 54 57 L 57 57" fill="none" stroke="#00ff88" stroke-width="1" opacity="0.2"/>

      <!-- Center dot -->
      <circle cx="50" cy="50" r="0.4" fill="#00ff88" opacity="0.9"/>
      <circle cx="50" cy="50" r="1" fill="#00ff88" opacity="0.2"/>

      <!-- Range markers on crosshairs - more visible -->
      <line x1="49" y1="30" x2="51" y2="30" stroke="#00ff88" stroke-width="0.2" opacity="0.7"/>
      <line x1="49" y1="35" x2="51" y2="35" stroke="#00ff88" stroke-width="0.15" opacity="0.5"/>
      <line x1="49" y1="40" x2="51" y2="40" stroke="#00ff88" stroke-width="0.15" opacity="0.5"/>
      
      <line x1="49" y1="60" x2="51" y2="60" stroke="#00ff88" stroke-width="0.15" opacity="0.5"/>
      <line x1="49" y1="65" x2="51" y2="65" stroke="#00ff88" stroke-width="0.15" opacity="0.5"/>
      <line x1="49" y1="70" x2="51" y2="70" stroke="#00ff88" stroke-width="0.2" opacity="0.7"/>
      
      <line x1="30" y1="49" x2="30" y2="51" stroke="#00ff88" stroke-width="0.2" opacity="0.7"/>
      <line x1="35" y1="49" x2="35" y2="51" stroke="#00ff88" stroke-width="0.15" opacity="0.5"/>
      <line x1="40" y1="49" x2="40" y2="51" stroke="#00ff88" stroke-width="0.15" opacity="0.5"/>
      
      <line x1="60" y1="49" x2="60" y2="51" stroke="#00ff88" stroke-width="0.15" opacity="0.5"/>
      <line x1="65" y1="49" x2="65" y2="51" stroke="#00ff88" stroke-width="0.15" opacity="0.5"/>
      <line x1="70" y1="49" x2="70" y2="51" stroke="#00ff88" stroke-width="0.2" opacity="0.7"/>

      <!-- Mil-dots - larger -->
      <circle cx="50" cy="27" r="0.5" fill="#00ff88" opacity="0.6"/>
      <circle cx="50" cy="73" r="0.5" fill="#00ff88" opacity="0.6"/>
      <circle cx="27" cy="50" r="0.5" fill="#00ff88" opacity="0.6"/>
      <circle cx="73" cy="50" r="0.5" fill="#00ff88" opacity="0.6"/>

      <!-- Inner ring -->
      <circle cx="50" cy="50" r="18" fill="none" stroke="#00ff88" stroke-width="0.1" opacity="0.3"/>
      
      <!-- Outer measurement ring with ticks -->
      <circle cx="50" cy="50" r="24" fill="none" stroke="#00ff88" stroke-width="0.15" opacity="0.4"/>
      
      <!-- Cardinal ticks on outer ring -->
      <line x1="50" y1="25.5" x2="50" y2="27" stroke="#00ff88" stroke-width="0.2" opacity="0.6"/>
      <line x1="50" y1="73" x2="50" y2="74.5" stroke="#00ff88" stroke-width="0.2" opacity="0.6"/>
      <line x1="25.5" y1="50" x2="27" y2="50" stroke="#00ff88" stroke-width="0.2" opacity="0.6"/>
      <line x1="73" y1="50" x2="74.5" y2="50" stroke="#00ff88" stroke-width="0.2" opacity="0.6"/>
      
      <!-- Diagonal ticks -->
      <line x1="32.5" y1="32.5" x2="33.5" y2="33.5" stroke="#00ff88" stroke-width="0.15" opacity="0.4"/>
      <line x1="67.5" y1="32.5" x2="66.5" y2="33.5" stroke="#00ff88" stroke-width="0.15" opacity="0.4"/>
      <line x1="32.5" y1="67.5" x2="33.5" y2="66.5" stroke="#00ff88" stroke-width="0.15" opacity="0.4"/>
      <line x1="67.5" y1="67.5" x2="66.5" y2="66.5" stroke="#00ff88" stroke-width="0.15" opacity="0.4"/>
    </svg>
  </div>

  <div class="scan-line"></div>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
  <script>
    const canvas = document.getElementById('scope-canvas');
    const scene = new THREE.Scene();
    
    scene.fog = new THREE.Fog(0x020405, 4, 14);

    const camera = new THREE.PerspectiveCamera(50, window.innerWidth / window.innerHeight, 0.1, 1000);
    camera.position.set(0, 0, 5);
    camera.lookAt(0, 0, 0);

    const renderer = new THREE.WebGLRenderer({ 
      canvas,
      antialias: true, 
      alpha: false
    });
    renderer.setClearColor(0x020405);
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));

    window.addEventListener('resize', () => {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    });

    const greenCandle = 0x00ff88;
    const redCandle = 0xff3333;

    const chartGroup = new THREE.Group();
    scene.add(chartGroup);

    // Generate candlestick data
    function generateCandleData(count) {
      const candles = [];
      let price = 100;
      
      for (let i = 0; i < count; i++) {
        const volatility = 1.5 + Math.random() * 3;
        const direction = Math.random() > 0.42 ? 1 : -1;
        const open = price;
        const close = price + direction * volatility * Math.random();
        const high = Math.max(open, close) + Math.random() * volatility * 0.5;
        const low = Math.min(open, close) - Math.random() * volatility * 0.5;
        
        candles.push({ open, high, low, close, bullish: close > open });
        price = close;
      }
      return candles;
    }

    const candleData = generateCandleData(28);
    const candleWidth = 0.08;
    const candleSpacing = 0.18;

    const allPrices = candleData.flatMap(c => [c.high, c.low]);
    const minPrice = Math.min(...allPrices);
    const maxPrice = Math.max(...allPrices);
    const priceRange = maxPrice - minPrice;
    const normalize = (price) => ((price - minPrice) / priceRange - 0.5) * 2;

    // Create candlesticks
    candleData.forEach((candle, i) => {
      const x = (i - candleData.length / 2) * candleSpacing;
      const z = (i - candleData.length / 2) * 0.08;
      
      const openY = normalize(candle.open);
      const closeY = normalize(candle.close);
      const highY = normalize(candle.high);
      const lowY = normalize(candle.low);
      
      const bodyHeight = Math.abs(closeY - openY);
      const bodyY = (openY + closeY) / 2;
      
      const color = candle.bullish ? greenCandle : redCandle;
      const opacity = 0.95 - ((candleData.length - 1 - i) * 0.02);
      
      // Body
      const bodyGeom = new THREE.BoxGeometry(candleWidth, Math.max(bodyHeight, 0.015), candleWidth * 0.6);
      const bodyMat = new THREE.MeshBasicMaterial({ color, transparent: true, opacity });
      const body = new THREE.Mesh(bodyGeom, bodyMat);
      body.position.set(x, bodyY, z);
      chartGroup.add(body);
      
      // Glow for recent candles
      if (i >= candleData.length - 6) {
        const glowGeom = new THREE.BoxGeometry(candleWidth * 2.5, Math.max(bodyHeight, 0.015) * 2, candleWidth * 2);
        const glowMat = new THREE.MeshBasicMaterial({ color, transparent: true, opacity: 0.1 });
        const glow = new THREE.Mesh(glowGeom, glowMat);
        glow.position.set(x, bodyY, z);
        chartGroup.add(glow);
      }
      
      // Wick
      const wickGeom = new THREE.CylinderGeometry(0.006, 0.006, highY - lowY, 4);
      const wickMat = new THREE.MeshBasicMaterial({ color, transparent: true, opacity: opacity * 0.6 });
      const wick = new THREE.Mesh(wickGeom, wickMat);
      wick.position.set(x, (highY + lowY) / 2, z);
      chartGroup.add(wick);
    });

    // Grid
    const gridHelper = new THREE.GridHelper(6, 20, 0x00ff88, 0x00ff88);
    gridHelper.material.transparent = true;
    gridHelper.material.opacity = 0.06;
    gridHelper.position.y = -1.2;
    chartGroup.add(gridHelper);

    // Price levels
    for (let i = 0; i < 5; i++) {
      const y = -0.8 + i * 0.4;
      const points = [new THREE.Vector3(-3, y, -1.5), new THREE.Vector3(3, y, 1.5)];
      const geom = new THREE.BufferGeometry().setFromPoints(points);
      const mat = new THREE.LineBasicMaterial({ color: 0x00ff88, transparent: true, opacity: 0.04 });
      chartGroup.add(new THREE.Line(geom, mat));
    }

    // Order block
    const obGeom = new THREE.BoxGeometry(1, 0.3, 0.3);
    const obMat = new THREE.MeshBasicMaterial({ color: 0x00ff88, transparent: true, opacity: 0.05 });
    const ob = new THREE.Mesh(obGeom, obMat);
    ob.position.set(0.8, -0.2, 0.6);
    chartGroup.add(ob);

    const obEdges = new THREE.EdgesGeometry(obGeom);
    const obLine = new THREE.LineSegments(obEdges, new THREE.LineBasicMaterial({ color: 0x00ff88, transparent: true, opacity: 0.25 }));
    obLine.position.copy(ob.position);
    chartGroup.add(obLine);

    // Liquidity sweep line
    const liqY = 0.9;
    const liqPoints = [];
    for (let i = 0; i < 30; i += 2) {
      liqPoints.push(new THREE.Vector3(-2.5 + i * 0.15, liqY, -1 + i * 0.06));
      liqPoints.push(new THREE.Vector3(-2.5 + (i + 0.7) * 0.15, liqY, -1 + (i + 0.7) * 0.06));
    }
    const liqGeom = new THREE.BufferGeometry().setFromPoints(liqPoints);
    const liqLine = new THREE.LineSegments(liqGeom, new THREE.LineBasicMaterial({ color: 0xff4444, transparent: true, opacity: 0.4 }));
    chartGroup.add(liqLine);

    // Target on current candle
    const lastCandle = candleData[candleData.length - 1];
    const lastX = (candleData.length - 1 - candleData.length / 2) * candleSpacing;
    const lastZ = (candleData.length - 1 - candleData.length / 2) * 0.08;
    const lastY = normalize(lastCandle.close);

    const targetGroup = new THREE.Group();
    
    const ringGeom = new THREE.RingGeometry(0.12, 0.15, 24);
    const ringMat = new THREE.MeshBasicMaterial({ color: 0x00ff88, transparent: true, opacity: 0.8, side: THREE.DoubleSide });
    const ring = new THREE.Mesh(ringGeom, ringMat);
    targetGroup.add(ring);

    const ring2Geom = new THREE.RingGeometry(0.2, 0.22, 24);
    const ring2Mat = new THREE.MeshBasicMaterial({ color: 0x00ff88, transparent: true, opacity: 0.3, side: THREE.DoubleSide });
    const ring2 = new THREE.Mesh(ring2Geom, ring2Mat);
    targetGroup.add(ring2);

    // Target cross
    [[0.25, 0, 0.1, 0], [-0.25, 0, -0.1, 0], [0, 0.25, 0, 0.1], [0, -0.25, 0, -0.1]].forEach(([x1, y1, x2, y2]) => {
      const pts = [new THREE.Vector3(x1, y1, 0), new THREE.Vector3(x2, y2, 0)];
      const g = new THREE.BufferGeometry().setFromPoints(pts);
      targetGroup.add(new THREE.Line(g, new THREE.LineBasicMaterial({ color: 0x00ff88, transparent: true, opacity: 0.9 })));
    });

    targetGroup.position.set(lastX + 0.25, lastY, lastZ + 0.05);
    chartGroup.add(targetGroup);

    // Particles
    const particleCount = 80;
    const particleGeom = new THREE.BufferGeometry();
    const particlePos = new Float32Array(particleCount * 3);
    for (let i = 0; i < particleCount; i++) {
      particlePos[i * 3] = (Math.random() - 0.5) * 12;
      particlePos[i * 3 + 1] = (Math.random() - 0.5) * 6;
      particlePos[i * 3 + 2] = (Math.random() - 0.5) * 10;
    }
    particleGeom.setAttribute('position', new THREE.BufferAttribute(particlePos, 3));
    const particles = new THREE.Points(particleGeom, new THREE.PointsMaterial({ color: 0x00ff88, size: 0.025, transparent: true, opacity: 0.35 }));
    scene.add(particles);

    // Animation
    let time = 0;
    function animate() {
      requestAnimationFrame(animate);
      time += 0.004;

      // Gentle rotation
      chartGroup.rotation.y = Math.sin(time * 0.4) * 0.3;
      chartGroup.rotation.x = Math.sin(time * 0.25) * 0.06;

      // Pulse target
      const pulse = Math.sin(time * 10) * 0.15 + 1;
      ring.scale.setScalar(pulse);
      ring.material.opacity = 0.6 + Math.sin(time * 10) * 0.25;
      ring2.scale.setScalar(1 + Math.sin(time * 6) * 0.1);

      // Target always faces camera
      targetGroup.lookAt(camera.position);

      // Particles drift
      particles.rotation.y = time * 0.05;

      // Subtle camera movement - stays centered
      camera.position.y = Math.sin(time * 0.3) * 0.1;
      camera.position.x = Math.sin(time * 0.2) * 0.15;
      camera.lookAt(0, 0, 0);

      renderer.render(scene, camera);
    }
    animate();
  </script>
</body>
</html>
